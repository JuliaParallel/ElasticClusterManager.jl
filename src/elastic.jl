# The master process listens on a well-known port
# Launched workers connect to the master and redirect their STDOUTs to the same
# Workers can join and leave the cluster on demand.

const HDR_COOKIE_LEN = Distributed.HDR_COOKIE_LEN

@static if Base.VERSION >= v"1.7-"
    # Base.errormonitor() is only available in Julia 1.7+
    my_errormonitor(t) = Base.errormonitor(t)
else
    my_errormonitor(t) = nothing
end

"""
    ElasticManager <: Distributed.ClusterManager

A cluster manager that allows for adding and removing workers dynamically.

Constructor:

```julia
function ElasticManager(;
    addr=IPv4("127.0.0.1"), port=9009, cookie=nothing,
    topology=:all_to_all, manage_callback=elastic_no_op_callback, printing_kwargs=()
)
```

The manager will listen for worker connections on `addr:port`. Workers have
to authenticate themselves with `cookie` (randomly generated by default).

If `manage_callback` is set to a user-provided `my_manage_callback`, it will
be called on the primary Julia process when `Distributed.manage` adds or
removes an elastic worker. The callback signature is

```julia
my_manage_callback(mgr::ElasticManager, id::Integer, :register)
my_manage_callback(mgr::ElasticManager, id::Integer, :deregister)
```

This can be used to automatically add workers to a `Distributed.WorkerPool`,
and so on.
"""
struct ElasticManager <: Distributed.ClusterManager
    active::Dict{Int, Distributed.WorkerConfig}        # active workers
    pending::Channel{Sockets.TCPSocket}          # to be added workers
    terminated::Set{Int}             # terminated worker ids
    topology::Symbol
    sockname
    manage_callback
    printing_kwargs

    function ElasticManager(;
        addr=IPv4("127.0.0.1"), port=9009, cookie=nothing,
        topology=:all_to_all, manage_callback=elastic_no_op_callback, printing_kwargs=()
    )
        Distributed.init_multi()
        cookie !== nothing && Distributed.cluster_cookie(cookie)

        # Automatically check for the IP address of the local machine
        if addr == :auto
            try
                addr = Sockets.getipaddr(Sockets.IPv4)
            catch
                error("Failed to automatically get host's IP address. Please specify `addr=` explicitly.")
            end
        end

        l_sock = Distributed.listen(addr, port)

        lman = new(Dict{Int, Distributed.WorkerConfig}(), Channel{Sockets.TCPSocket}(typemax(Int)), Set{Int}(), topology, Sockets.getsockname(l_sock), manage_callback, printing_kwargs)

        t1 = @async begin
            while true
                let s = Sockets.accept(l_sock)
                    t2 = @async process_worker_conn(lman, s)
                    my_errormonitor(t2)
                end
            end
        end
        my_errormonitor(t1)

        t3 = @async process_pending_connections(lman)
        my_errormonitor(t3)

        lman
    end
end

@deprecate ElasticManager(port) ElasticManager(;port=port)
@deprecate ElasticManager(addr, port) ElasticManager(;addr=addr, port=port)
@deprecate ElasticManager(addr, port, cookie) ElasticManager(;addr=addr, port=port, cookie=cookie)

elastic_no_op_callback(::ElasticManager, ::Integer, ::Symbol) = nothing

function process_worker_conn(mgr::ElasticManager, s::Sockets.TCPSocket)
    @debug "ElasticManager got new worker connection"
    # Socket is the worker's STDOUT
    wc = Distributed.WorkerConfig()
    wc.io = s

    # Validate cookie
    cookie = read(s, HDR_COOKIE_LEN)
    if length(cookie) < HDR_COOKIE_LEN
        error("Cookie read failed. Connection closed by peer.")
    end
    self_cookie = Distributed.cluster_cookie()
    for i in 1:HDR_COOKIE_LEN
        if UInt8(self_cookie[i]) != cookie[i]
            println(i, " ", self_cookie[i], " ", cookie[i])
            error("Invalid cookie sent by remote worker.")
        end
    end

    put!(mgr.pending, s)
end

function process_pending_connections(mgr::ElasticManager)
    while true
        wait(mgr.pending)
        try
            Distributed.addprocs(mgr; topology=mgr.topology)
        catch e
            showerror(stderr, e)
            Base.show_backtrace(stderr, Base.catch_backtrace())
        end
    end
end

function Distributed.launch(mgr::ElasticManager, params::Dict, launched::Array, c::Condition)
    # The workers have already been started.
    while isready(mgr.pending)
        @debug "ElasticManager.launch new worker"
        wc=Distributed.WorkerConfig()
        wc.io = take!(mgr.pending)
        push!(launched, wc)
    end

    notify(c)
end

function Distributed.manage(mgr::ElasticManager, id::Integer, config::Distributed.WorkerConfig, op::Symbol)
    if op == :register
        @debug "ElasticManager registering process id $id"
        mgr.active[id] = config
        mgr.manage_callback(mgr, id, op)
    elseif  op == :deregister
        @debug "ElasticManager deregistering process id $id"
        mgr.manage_callback(mgr, id, op)
        delete!(mgr.active, id)
        push!(mgr.terminated, id)
    end
end

function Base.show(io::IO, mgr::ElasticManager)
    iob = IOBuffer()

    println(iob, "ElasticManager:")
    print(iob, "  Active workers : [ ")
    for id in sort(collect(keys(mgr.active)))
        print(iob, id, ",")
    end
    seek(iob, position(iob)-1)
    println(iob, "]")

    println(iob, "  Number of workers to be added  : ", Base.n_avail(mgr.pending))

    print(iob, "  Terminated workers : [ ")
    for id in sort(collect(mgr.terminated))
        print(iob, id, ",")
    end
    seek(iob, position(iob)-1)
    println(iob, "]")

    println(iob, "  Worker connect command : ")
    print(iob, "    ", get_connect_cmd(mgr; mgr.printing_kwargs...))

    print(io, String(take!(iob)))
end

"""
    ElasticClusterManager.elastic_worker(
        cookie::AbstractString, addr::AbstractString="127.0.0.1", port::Integer = 9009;
        forward_stdout::Bool = true,
        Base.@nospecialize(env::AbstractVector = [],)
    )

Start an elastic worker process that connects to the main Julia process
at IP-address `addr` and port `port`.

Does not return.
"""
function elastic_worker(
    cookie::AbstractString, addr::AbstractString="127.0.0.1", port::Integer = 9009;
    forward_stdout::Bool = true,
    Base.@nospecialize(env::AbstractVector = [],)
)
    @debug "ElasticManager.elastic_worker(cookie, $addr, $port; forward_stdout=$forward_stdout, env=$env)"
    for (k, v) in env
        ENV[k] = v
    end

    c = connect(addr, port)
    write(c, rpad(cookie, HDR_COOKIE_LEN)[1:HDR_COOKIE_LEN])
    if forward_stdout
        redirect_stdout(c)
    end
    Distributed.start_worker(c, cookie)
end

function get_connect_cmd(em::ElasticManager; absolute_exename=true, same_project=true, exeflags::Tuple=())
    ip = string(em.sockname[1])
    port = convert(Int,em.sockname[2])
    cookie = Distributed.cluster_cookie()
    exename = absolute_exename ? joinpath(Sys.BINDIR, Base.julia_exename()) : "julia"
    project = same_project ? ("--project=$(Pkg.API.Context().env.project_file)",) : ()

    join([
        exename,
        exeflags...,
        project...,
        "-e 'import ElasticClusterManager; ElasticClusterManager.elastic_worker(\"$cookie\",\"$ip\",$port)'"
    ]," ")

end
